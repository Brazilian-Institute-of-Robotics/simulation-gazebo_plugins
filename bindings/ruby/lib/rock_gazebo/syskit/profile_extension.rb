module RockGazebo
    module Syskit
        module ProfileExtension
            attr_reader :sdf_world_name

            def use_sdf_model(*path, as: nil, world_frame: 'world')
                # This is a guard used by
                # ConfigurationExtension#use_gazebo_world to verify that
                # #use_gazebo_world was called first. Otherwise, devices for the
                # world models won't be defined and stuff like vizkit3d_world
                # won't be configured properly
                Conf.gazebo.has_profile_loaded = true

                # Normalize the path to a model. We actually normalize to a Root
                # so that we can pass either a World or a Model to the setup
                # models
                if path.size == 1 && !path.first.respond_to?(:to_str)
                    # Assume this is a SDF::Model object
                    model = path.first
                else
                    _, resolved_paths = Rock::Gazebo.resolve_worldfiles_and_models_arguments([File.join(*path)])
                    full_path = resolved_paths.first
                    if !File.file?(full_path)
                        raise ArgumentError, "#{File.join(*path)} cannot be resolved to a valid gazebo world"
                    end

                    models = SDF::Root.load(full_path).each_model.to_a
                    if models.size > 1
                        raise ArgumentError, "#{full_path} has more than one model, cannot use in use_sdf_model"
                    elsif models.empty?
                        raise ArgumentError, "#{full_path} has no models, cannot use in use_sdf_model"
                    end
                    model = models.first
                end
                as ||= model.name

                # Load the model in the syskit subsystems
                if Conf.gazebo.world?
                    robot.load_sdf(Conf.gazebo.world.make_root)
                    world_frame = Conf.gazebo.world.full_name
                else
                    robot.load_sdf(model.make_root)
                end
                @sdf_world_name = world_frame
                if !(device = robot.find_device(model.name))
                    raise RuntimeError, "cannot resolve device #{model.name}, it should have been created by RobotDefinitionExtension#load_sdf, got #{robot.each_master_device.map(&:name).sort.join(", ")}"
                end
                transformer.load_sdf(model)

                # Declare the transformations that can be generated by the
                # ModelTask on the transformer
                model.each_link do |link|
                    producer = OroGen::RockGazebo::ModelTask.specialize
                    srv_name = "world2#{link.name.gsub(/[^\w]+/, '_')}"

                    srv = producer.require_dynamic_service 'link_export', as: srv_name
                    producer = producer.to_instance_requirements
                    producer.
                        prefer_deployed_tasks(/^gazebo:\w+:#{model.name}$/).
                        with_arguments('model_dev' => device).
                        use_frames("#{srv.name}_source" => link.full_name,
                                   "#{srv.name}_target" => world_frame).
                        select_service(srv)
                    transformer.dynamic_transform producer, link.full_name => world_frame
                end
            end

        end
        ::Syskit::Actions::Profile.include ProfileExtension
    end
end
